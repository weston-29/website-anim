<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Weston Keller ASCII</title>
<style>
  body {
    background: white;
    color: white;
    font-family: monospace;
    height: 100vh;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    perspective: 800px;
    overflow: hidden;
  }
  #ascii {
    font-size: 14px;
    white-space: pre;
    text-align: center;
    line-height: 0.8; /* less than 1 = lines closer vertically */
  }
  .ascii-line {
    display: block;
    will-change: transform;
  }
</style>
</head>
<body>
<pre id="ascii"></pre>
<script>
const ascii = document.getElementById("ascii");
const asciiArt = `
██     ██  ██    ██    
██     ██  ██  ██      
██  █  ██  ██ ██       
██ ███ ██  ██  ██      
 ██   ██   ██    ██  ██
`;
const symbols = '!@#$%&*+=~˚≈¢∞§░';
// Split lines and wrap in spans
const lines = asciiArt.trim().split('\n');
ascii.innerHTML = lines.map(line => `<span class="ascii-line">${line}</span>`).join('\n');
const spans = ascii.querySelectorAll('.ascii-line');
// ----- Scramble Animation -----
let iteration = 0;
const totalIterations = 40;
function randomSymbol() {
  return symbols[Math.floor(Math.random() * symbols.length)];
}
function scramble() {
  // Color interpolation from orange (#fab641) to black (#000000)
  const startColor = { r: 255, g: 255, b: 255 };  // #ffffff
  const endColor = { r: 255, g: 100, b: 33 };      // blue
  
  const progress = iteration / totalIterations;
  const r = Math.round(startColor.r + (endColor.r - startColor.r) * progress);
  const g = Math.round(startColor.g + (endColor.g - startColor.g) * progress);
  const b = Math.round(startColor.b + (endColor.b - startColor.b) * progress);
  
  spans.forEach((span, i) => {
    const line = lines[i];
    let output = '';
    for (let j = 0; j < line.length; j++) {
      if (Math.random() < (1 - iteration / totalIterations)) {
        output += randomSymbol();
      } else {
        output += line[j];
      }
    }
    span.textContent = output;
    span.style.color = `rgb(${r}, ${g}, ${b})`;
  });
  iteration++;
  if (iteration <= totalIterations) {
    const delay = 50 * Math.pow(1.05, iteration); // Starts at 50ms, grows exponentially
    setTimeout(scramble, delay);
  }
}
window.onload = scramble;
// ----- Bounce Physics -----
const spring = 0.2;
const damping = 0.7;
const maxOffset = 30;
const lineStates = Array.from(spans).map(() => ({ x: 0, vx: 0 }));
let cursorX = 0;
let cursorY = 0;
let isMouseInside = false;
document.addEventListener("mousemove", (e) => {
  cursorX = e.clientX;
  cursorY = e.clientY;
  isMouseInside = true;
});
document.addEventListener("mouseleave", () => {
  isMouseInside = false;
});
function animate() {
  spans.forEach((span, i) => {
    const rect = span.getBoundingClientRect();
    const state = lineStates[i];
    // Only apply bounce if cursor is vertically over this line
    let desiredX = 0;
    if (isMouseInside && cursorY >= rect.top && cursorY <= rect.bottom) {
      const xNorm = (cursorX / window.innerWidth - 0.5) * 2; // -1 to 1
      desiredX = xNorm * maxOffset;
    }
    const ax = (desiredX - state.x) * spring;
    state.vx = (state.vx + ax) * damping;
    state.x += state.vx;
    span.style.transform = `translateX(${state.x}px)`;
  });
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
