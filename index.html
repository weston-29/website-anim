<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Weston Keller ASCII</title>
<style>
  body {
    background: white;
    color: #7A45FF;
    font-family: monospace;
    height: 100vh;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    perspective: 800px;
    overflow: hidden;
  }
  #ascii {
    font-size: 14px;
    white-space: pre;
    text-align: center;
    line-height: 0.9; /* tighter spacing */
  }
  .ascii-line {
    display: block;
    will-change: transform;
  }
</style>
</head>
<body>
<pre id="ascii"></pre>
<script>
const ascii = document.getElementById("ascii");

const asciiArt = `
██     ██  ██    ██    
██     ██  ██  ██      
██  █  ██  ██ ██       
██ ███ ██  ██  ██      
 ███ ███   ██    ██  ██
`;

const symbols = '!@#$%&/+';

// Split lines and wrap in spans
const lines = asciiArt.trim().split('\n');
ascii.innerHTML = lines.map(line => `<span class="ascii-line">${line}</span>`).join('\n');
const spans = ascii.querySelectorAll('.ascii-line');

// ----- Scramble Animation -----
let iteration = 0;
const totalIterations = 30;

function randomSymbol() {
  return symbols[Math.floor(Math.random() * symbols.length)];
}

function scramble() {
  spans.forEach((span, i) => {
    const line = lines[i];
    let output = '';
    for (let j = 0; j < line.length; j++) {
      if (Math.random() < (1 - iteration / totalIterations)) {
        output += randomSymbol();
      } else {
        output += line[j];
      }
    }
    span.textContent = output;
  });
  iteration++;
  if (iteration <= totalIterations) {
    setTimeout(scramble, 50);
  }
}

window.onload = scramble;

// ----- Bounce Physics -----
const spring = 0.2;
const damping = 0.7;
const maxOffset = 30; // max lateral movement

const lineStates = Array.from(spans).map(() => ({ x: 0, vx: 0 }));

let cursorX = 0;
let cursorY = 0;
let isMouseInside = false;

document.addEventListener("mousemove", (e) => {
  cursorX = e.clientX;
  cursorY = e.clientY;
  isMouseInside = true;
});

document.addEventListener("mouseleave", () => {
  isMouseInside = false;
});

// Animation loop
function animate() {
  spans.forEach((span, i) => {
    const rect = span.getBoundingClientRect();
    const state = lineStates[i];

    let desiredX = 0;

    // Only bounce if cursor is vertically over this line
    if (isMouseInside && cursorY >= rect.top && cursorY <= rect.bottom) {
      const lineCenterX = rect.left + rect.width / 2;
      const distance = Math.abs(cursorX - lineCenterX);
      const maxDistance = rect.width; // full line width
      const proximity = Math.max(0, 1 - distance / maxDistance); // stronger when closer
      const direction = cursorX < lineCenterX ? -1 : 1; // move away from cursor
      desiredX = direction * proximity * maxOffset;
    }

    // Spring physics
    const ax = (desiredX - state.x) * spring;
    state.vx = (state.vx + ax) * damping;
    state.x += state.vx;

    span.style.transform = `translateX(${state.x}px)`;
  });

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
