<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Weston Keller ASCII</title>
<style>
  body {
    background: white;
    color: #7A45FF;
    font-family: monospace;
    height: 200vh; /* Make page scrollable */
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    perspective: 800px;
    overflow-x: hidden; /* Prevent horizontal scroll */
  }
  #ascii {
    font-size: 14px;
    white-space: pre;
    text-align: center;
    line-height: 0.8;
    position: fixed; /* Keep ASCII centered while scrolling */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  .ascii-line {
    display: block;
    will-change: transform;
    transition: none; /* We'll handle transitions via JS */
  }
</style>
</head>
<body>
<pre id="ascii"></pre>
<script>
const ascii = document.getElementById("ascii");
const asciiArt = `
██     ██  ██    ██    
██     ██  ██  ██      
██  █  ██  ██ ██       
██ ███ ██  ██  ██      
 ██   ██   ██    ██  ██
`;
const symbols = '!@#$%&/+?~=';
// Split lines and wrap in spans
const lines = asciiArt.trim().split('\n');
ascii.innerHTML = lines.map(line => `<span class="ascii-line">${line}</span>`).join('\n');
const spans = ascii.querySelectorAll('.ascii-line');
// ----- Scramble Animation -----
let iteration = 0;
const totalIterations = 30;
function randomSymbol() {
  return symbols[Math.floor(Math.random() * symbols.length)];
}
function scramble() {
  spans.forEach((span, i) => {
    const line = lines[i];
    let output = '';
    for (let j = 0; j < line.length; j++) {
      if (Math.random() < (1 - iteration / totalIterations)) {
        output += randomSymbol();
      } else {
        output += line[j];
      }
    }
    span.textContent = output;
  });
  iteration++;
  if (iteration <= totalIterations) {
    setTimeout(scramble, 50);
  }
}
window.onload = scramble;
// ----- Bounce Physics -----
const spring = 0.2;
const damping = 0.7;
const maxOffset = 30;
const lineStates = Array.from(spans).map(() => ({ x: 0, vx: 0 }));
let cursorX = 0;
let cursorY = 0;
let isMouseInside = false;
document.addEventListener("mousemove", (e) => {
  cursorX = e.clientX;
  cursorY = e.clientY;
  isMouseInside = true;
});
document.addEventListener("mouseleave", () => {
  isMouseInside = false;
});
// ----- Scroll-based Row Animation -----
let scrollOffset = 0;
const maxScrollOffset = 200; // Maximum pixels to move offscreen
function updateScroll() {
  const scrollY = window.scrollY;
  const maxScroll = document.body.scrollHeight - window.innerHeight;
  const scrollProgress = Math.min(scrollY / maxScroll, 1); // 0 to 1
  scrollOffset = scrollProgress * maxScrollOffset;
}
window.addEventListener('scroll', updateScroll);
function animate() {
  spans.forEach((span, i) => {
    const rect = span.getBoundingClientRect();
    const state = lineStates[i];
    
    // Mouse bounce effect (only if cursor is over this line)
    let mouseOffsetX = 0;
    if (isMouseInside && cursorY >= rect.top && cursorY <= rect.bottom) {
      const xNorm = (cursorX / window.innerWidth - 0.5) * 2; // -1 to 1
      mouseOffsetX = xNorm * maxOffset;
    }
    
    // Apply spring physics for mouse interaction
    const ax = (mouseOffsetX - state.x) * spring;
    state.vx = (state.vx + ax) * damping;
    state.x += state.vx;
    
    // Scroll-based alternating movement
    const isEvenRow = i % 2 === 0;
    const scrollOffsetX = isEvenRow ? scrollOffset : -scrollOffset;
    
    // Color fade based on scroll progress
    const scrollY = window.scrollY;
    const maxScroll = document.body.scrollHeight - window.innerHeight;
    const scrollProgress = Math.min(scrollY / maxScroll, 1); // 0 to 1
    
    // Interpolate from purple (#7A45FF) to white (#FFFFFF)
    const purple = { r: 122, g: 69, b: 255 };
    const white = { r: 255, g: 255, b: 255 };
    
    const r = Math.round(purple.r + (white.r - purple.r) * scrollProgress);
    const g = Math.round(purple.g + (white.g - purple.g) * scrollProgress);
    const b = Math.round(purple.b + (white.b - purple.b) * scrollProgress);
    
    // Combine both effects
    const totalX = state.x + scrollOffsetX;
    span.style.transform = `translateX(${totalX}px)`;
    span.style.color = `rgb(${r}, ${g}, ${b})`;
  });
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
